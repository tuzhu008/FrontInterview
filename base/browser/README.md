# 浏览器

## 多进程

浏览器是多进程的

* Browser 进程

  浏览器主进程，只有一个。作用：

  * 负责浏览器的界面显示，与用户交互，如前进，后退等
  * 负责各个页面的管理，创建和销毁其它进程
  * 将 Rendered 进程得到的内存中的 Bitmap，绘制到用户界面上
  * 网络资源的管理，下载

* 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。

* GPU进程：最多一个，用于 3D 绘制等。

* Render 进程，浏览器渲染进程（浏览器内核），内部是多线程的

  默认每个Tab页面一个进程，互不影响。主要作用为：

  * 页面渲染，脚本执行，事件处理等

### 浏览器多进程的优势

* 避免单个 page crash 影响整个浏览器
* 避免第三方插件 crash 影响整个浏览器
* 多进程充分利用多核优势
* 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

### Render 进程

对于普通的前端操作来说，最重要的渲染进程：页面的渲染，js的执行，事件的循环等都在这个进程内执行;

浏览器是多进程的，浏览器的渲染进程是多线程的；

#### GUI 渲染线程

* 负责渲染浏览器界面，解析 HTML,CSS,构建 DOM 树和 RenderObject 树，布局和绘制等。
* 当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
* 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于冻结了）,GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

#### JS 引擎线程

* 也称为 JS 内核，负责处理 JavaScript 脚本程序。（例如V8引擎）。
* JS 引擎线程负责解析 JavaScript 脚本，运行代码。
* JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（render进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。
* 同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

#### 事件触发线程

* 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解成JS引擎自己都忙不过来，需要浏览器另开线程协助）。
* 当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其它线程，如鼠标点击，AJAX异步请求等），会将对应任务添加到事件线程中。
* 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。
* 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当JS引擎空闲时才会去执行）。

#### 定时触发器线程

* 传说中的 `setTimeout` 和 `setInterval` 所在的线程
* 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）
* 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
* 注意，W3C 在 HTML 标准中规定，规定要求 `setTimeout` 中低于 4ms 的时间间隔算为 4ms。

#### 异步http请求线程

* 在 XMLHttpRequest 在连接后是通过浏览器新建一个线程请求
* 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行

![](/assets/浏览器渲染进程.png)

### Browser 主进程和浏览器内核（渲染进程）的通信过程

打开一个浏览器，可以看到：任务管理器出现了 2 个进程（一个主进程，一个是打开 Tab 页的渲染进程）；

* Browser 主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过RendererHost接口传递给Render渲染进程
* Render渲染进程的Renderer接口收到消息，简单解释后，交给渲染线程GUI，然后开始渲染
* GUI渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser主进程获取资源和需要GPU进程来帮助渲染
* 当然可能会有JS线程操作DOM（这可能会造成回流并重绘）
* 最后Render渲染进程将结果传递给Browser主进程
* Browser主进程接收到结果并将结果绘制出来
