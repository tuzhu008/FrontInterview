# 浏览器

## 多进程

浏览器是多进程的

* Browser 进程

  浏览器主进程，只有一个。作用：

  * 负责浏览器的界面显示，与用户交互，如前进，后退等
  * 负责各个页面的管理，创建和销毁其它进程
  * 将 Rendered 进程得到的内存中的 Bitmap，绘制到用户界面上
  * 网络资源的管理，下载

* 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。

* GPU进程：最多一个，用于 3D 绘制等。

* Render 进程，浏览器渲染进程（浏览器内核），内部是多线程的

  默认每个Tab页面一个进程，互不影响。主要作用为：

  * 页面渲染，脚本执行，事件处理等

### 浏览器多进程的优势

* 避免单个 page crash 影响整个浏览器
* 避免第三方插件 crash 影响整个浏览器
* 多进程充分利用多核优势
* 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

### Render 进程

对于普通的前端操作来说，最重要的渲染进程：页面的渲染，js的执行，事件的循环等都在这个进程内执行;

浏览器是多进程的，浏览器的渲染进程是多线程的；

#### GUI 渲染线程

* 负责渲染浏览器界面，解析 HTML,CSS,构建 DOM 树和 RenderObject 树，布局和绘制等。
* 当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
* 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于冻结了）,GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

#### JS 引擎线程

* 也称为 JS 内核，负责处理 JavaScript 脚本程序。（例如V8引擎）。
* JS 引擎线程负责解析 JavaScript 脚本，运行代码。
* JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（render进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。
* 同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

#### 事件触发线程

* 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解成JS引擎自己都忙不过来，需要浏览器另开线程协助）。
* 当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其它线程，如鼠标点击，AJAX异步请求等），会将对应任务添加到事件线程中。
* 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。
* 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当JS引擎空闲时才会去执行）。

#### 定时触发器线程

* 传说中的 `setTimeout` 和 `setInterval` 所在的线程
* 浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）
* 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
* 注意，W3C 在 HTML 标准中规定，规定要求 `setTimeout` 中低于 4ms 的时间间隔算为 4ms。

#### 异步http请求线程

* 在 XMLHttpRequest 在连接后是通过浏览器新建一个线程请求
* 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行

![](/assets/浏览器渲染进程.png)

### Browser 主进程和浏览器内核（渲染进程）的通信过程

打开一个浏览器，可以看到：任务管理器出现了 2 个进程（一个主进程，一个是打开 Tab 页的渲染进程）；

* Browser 主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过 RendererHost 接口传递给 Render 渲染进程
* Render 渲染进程的 Renderer 接口收到消息，简单解释后，交给渲染线程 GUI，然后开始渲染
* GUI 渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 主进程获取资源和需要 GPU 进程来帮助渲染
* 当然可能会有 JS 线程操作 DOM（这可能会造成回流并重绘）
* 最后 Render 渲染进程将结果传递给 Browser 主进程
* Browser 主进程接收到结果并将结果绘制出来

![](/assets/浏览器渲染.png)

### 浏览器内核（渲染进程）中线程之间的关系

GUI 渲染线程与 JS 引擎线程互斥

由于JavaScript是可操作DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和GUI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当JS引擎执行时GUI线程会被挂起。GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

**JS阻塞页面加载**

从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。

譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存在队列中，要等到JS引擎空闲后执行。然后由于巨量计算，所以JS引擎可能很久很久才能空闲，肯定就会感觉很卡。

所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

**css加载是否会阻塞dom树渲染**

这里说的是头部引入css的情况

首先，我们都知道：css是由单独的下载线程异步下载的。

然后还有几个现象：  
1. css加载不会阻塞DOM树解析（异步加载时dom照常构建）  
2. 但会阻塞render树渲染（渲染时需要等css加载完毕，因为render树需要css信息）

这可能也是浏览器的一种优化机制  
因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后，render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗  
所以干脆把DOM树的结构先解析完，把可以做的工作做完，然后等css加载完之后，在根据最终的样式来渲染render树，这种做法确实对性能好一点。

### 总结浏览器渲染流程

> 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Render进程--浏览器渲染流程开始

浏览器内核拿到内容后，渲染大概可以划分为：

1. 解析html建立dom树
2. 解析css构建render树（将css代码解析成树形的数据结构，然后结合dom合并成render树）
3. 布局render树（Layout/reflow）,负责各元素尺寸，位置的计算
4. 绘制render树（paint），绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite）,显示在屏幕上

渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了，略去了详细步骤。

**load事件与DOMContentLoaded事件的先后**

上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？

很简单，知道它们的定义就可以了：

当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。  
\(譬如如果有async加载的脚本就不一定完成\)

当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了）

所以，顺序是：DOMContentLoaded -&gt; load

## 普通图层和复合图层

渲染步骤就提到了composite概念;浏览器渲染的图层一般包含两大类：普通图层以及复合图层。

1. 普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）
2. absolute布局（fixed也一样），虽然可以脱离文档流，但它仍然属于默认复合层
3. 可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）
   可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒

**如何变成复合图层（硬件加速）**

将元素变成一个复合图层，就是传说中的硬件加速技术

* 最常用的方式：`translate3d`，`translatez`
* opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
* will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
* `<video>`、`<iframe>`、`<canvas>`、`<webgl>`等元素
* 其它，譬如以前的 flash 插件

**absolute 和硬件加速的区别**

可以看到，`absolute` 虽然可以脱离普通文档流，但是**无法**脱离默认复合层。

所以，就算 `absolute` 中信息改变时不会改变普通文档流中 render 树，但是，浏览器最终绘制时，是整个复合层绘制的，所以`absolute` 中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute 带来的绘制信息变化过大，资源消耗是非常严重的）

而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）

**复合图层的作用**

一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。

但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。

**硬件加速时请使用index**

使用硬件加速时，尽可能的使用index,防止浏览器默认给后续的元素创建复合层渲染

具体的原理是：

webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且relective或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能

简单点理解，可以认为是一个隐式合成的概念：如果a是一个复合层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意

## 从Event Loop谈JS的运行机制

到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS 引擎的一些运行机制分析。主要是结合 Event Loop 来谈 JS 代码是如何执行的。

我们已经知道了 JS 引擎是单线程的，知道了 JS 引擎线程，事件触发线程，定时触发器线程。

然后还需要知道：

* JS分为同步任务和异步任务
* 同步任务都在主线程上执行，形成一个执行栈
* 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件
* 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。

![](/assets/js执行.png)

看到这里，应该就可以理解了：为什么有时候 `setTimeOut` 推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以就必须等待，自然有误差。

![](/assets/eventloop.png)

## 参考

[原文地址](https://segmentfault.com/a/1190000014018604)

