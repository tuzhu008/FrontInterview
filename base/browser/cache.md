## 缓存的分类

在 [HTTP Caching](https://httpwg.org/specs/rfc9111.html) 标准中，有两种不同类型的缓存：**私有缓存**和**共享缓存**。

### 私有缓存

私有缓存是绑定到特定客户端的缓存——通常是浏览器缓存。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。

```
Cache-Control: private;
```

### 共享缓存

共享缓存位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为代理缓存和托管缓存。

![缓存分类](/base/browser/assets/shared-cache.png)

## 启发式缓存

HTTP 旨在尽可能多地缓存，因此即使没有给出 `Cache-Control`，如果满足某些条件，响应也会被存储和重用。这称为**启发式缓存**。
启发式缓存是在 `Cache-Control` 被广泛采用之前出现的一种解决方法，基本上所有响应都应明确指定 `Cache-Control` 标头。

通常客户端一句相应的最后修改时间与当前时间差值的 10% 来作为缓存最长时间，（尽管缺少 `max-age`）。具体复用多长时间取决于实现，但规范建议存储后大约 10%（在本例中为 0.1 年）的时间。

## 缓存机制

浏览器有两种缓存机制——**强缓存**和**协商缓存**。


### 强缓存
强缓存不会向服务器发送请求，直接从缓存中读取资源


#### 强缓存原理

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

* 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求

![强缓存-1](/base/browser/assets/qianghuancun1.png)

* 存在缓存标识和缓存结果，但是已经失效，强制缓存是啊比，则使用协商缓存（暂不分析）

![强缓存-2](/base/browser/assets/qianghuancun2.png)

* 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

![强缓存-3](/base/browser/assets/qianghuancun3.png)

#### 强缓存规则

那么强制缓存的缓存规则是什么？

当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中`Cache-Control` 优先级比 `Expires` 高。

#### `Cache-Control`

`Cache-Control` 通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。
指令格式具有以下有效规则：

* 不区分大小写，但建议使用小写。
* 多个指令以逗号分隔。
* 具有可选参数，可以用令牌或者带引号的字符串语法。

![Cache-Control](/base/browser/assets/cache-control.png)

| Cache-Control | 请求 | 响应 | 描述 |
| --- | --- | --- | --- |
| `max-age=<seconds>` | 表示客户端不愿意接受年龄大于指定秒数的响应。在使用中通常采用 `max-age=0` 来始终进行验证。 | 设置缓存存储的最大周期，超过这个时间缓存被认为过期 (单位秒)。与 `Expires` 相反，时间是相对于请求的时间 | |
| `max-stale[=<seconds>]` | 表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。 |  |  |
| `min-fresh=<seconds>` | 表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。 |  |  |
| `no-cache` | 即便在客户端拥有未过期的缓存，也要向服务器请求获得最新的资源。
no-cache 指令不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应。 |  | 与 `If-None-Match` 和 `If-Modified-Since` 一起使用可以达到条件请求的目的。不与 ·If-None-Match` 和 `If-Modified-Since` 使用时，会始终使用最新的 200 响应 |
| `no-store` | 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。 |  |  |
| `no-transform` | 不得对资源进行转换或转变。Content-Encoding、Content-Range、Content-Type等 HTTP 头不能由代理修改。 |  |  |
| only-if-cached | 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。 |  |  |
| `must-revalidate`  |  | 一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。 |  |
| `public` |  | 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。 |  |
| `private` |  | 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。 |  |
| `proxy-revalidate` |  | 与 `must-revalidate` 作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。 |  |
| `s-maxage=<seconds>` |  | 覆盖 `max-age` 或者`Expires` 头，但是仅适用于共享缓存 (比如各个代理)，私有缓存会忽略它。 |  |
| `immutable` | 表示响应正文不会随时间而改变。 |  |  |
| `stale-while-revalidate=<seconds>` | 表明客户端愿意接受陈旧的响应，同时在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度。 | |  |
| `stale-if-error=<seconds>` | 表示如果新的检查失败，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。 |  |  |

> 需要注意的是，`no-cache` 这个名字有一点误导。设置了`no-cache` 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而 `no-store` 才表示不会被缓存，即不使用强制缓存，也不使用协商缓存。


#### Expires

Expires 响应头包含日期/时间，即在此时候之后，响应过期。值为时间戳。

如果在 Cache-Control 响应头设置了 `max-age` 或者 `s-max-age` 指令，那么 `Expires` 头会被忽略。

`Expires` 是Web服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

> Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

### 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

* 协商缓存生效，返回 `304` 和 `Not Modified`

![协商缓存-1](/base/browser/assets/xieshanghuancun1.png)

* 协商缓存失效，返回 `200` 和请求结果

![协商缓存-2](/base/browser/assets/xieshanghuancun2.png)


#### `Last-Modified` 和 `If-Modified-Since`

1. 浏览器首先发送一个请求，让服务端在 response header 中返回请求的资源上次更新时间，就是 `last-modified`，浏览器会缓存下这个时间。

2. 然后浏览器再下次请求中，request header 中带上`if-modified-since:[保存的last-modified的值]`。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。

由于 `last-modified` 依赖的是保存的绝对时间，还是会出现误差的情况：

1. 保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；
2. 各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。

#### `ETag` 和 `If-None-Match`

`etag` 是 http 协议提供的若干机制中的一种 Web 缓存验证机制，并且允许客户端进行缓存协商。生成 `etag` 常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和 `last-modified` 一样。

* 浏览器会先发送一个请求得到 `etag` 的值，然后再下一次请求在 request header 中带上 `if-none-match:[保存的etag的值]`。

* 通过发送的 `etag` 的值和服务端重新生成的 `etag` 的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。

> `etag` 能够解决 `last-modified` 的一些缺点，但是 `etag` 每次服务端生成都需要进行读写操作，而 `last-modified` 只需要读取操作，从这方面来看，`etag` 的消耗是更大的。

二者对比 - 精确度上：`Etag` 要优于 `Last-Modified`。

**优先级**：服务器校验优先考虑 Etag

**性能**：`Etag` 要逊于 `Last-Modified`

## 用户行为对浏览器缓存的影响

1. 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。

2. 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。

3. 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control: no-cache`(为了兼容，还带了 `Pragma:no-cache` )，服务器直接返回 200 和最新内容。