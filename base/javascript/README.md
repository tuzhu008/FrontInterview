# JavaScript

## null 和 undefined 的区别

* 意义不同

  `null` 是一个表示空对象

  `undefined` 是一个表示无的原始值

* 数值转换

  `null` 可以转为数值 0

  `undefined` 可以转为数值 NaN

* `null` 是一个 JavaScript 保留关键字，`undefined` 不是

## new 操作符都干了什么？

* 创建了一个空对象，
* 链接到原型：将该对象的 `__proto__` 属性指向构造函数的 `prototype` 属性
* 绑定 this 指向：将 this 变量引用指向该对象
* 执行构造函数，返回对象

### 实现一个 new

```js
function _new (fn, ...args) {
  const obj = Object.create(fn.prototype);
  const result = fn.apply(obj, args);
  return result instanceOf Object ? result : obj;
}
```

## 对 JSON 的了解

JSON 是一种轻量级的数据交换格式，它是基于 JavaSript 的一个子集。数据格式简单，易于读写，占用带宽小。

## JS 延迟加载的方式有哪些？

1. defer：开启新县城下载脚本，并使脚本在文档解析完成后执行
2. async：HTML5 新增属性，用于异步下载脚本文件，下载完成立即解释执行代码
3. 动态创建 DOM 方式
4. 按需异步载入

## 如何解决跨域问题

* jsonp：其原理是利用带有 `src` 的元素具有跨域的性质，以动态插入 script 标签的方式进行请求
* document.domain + iframe
* window.name、window.postMessage
* 服务器设置代理
* CORS：设置 http 头，Access-Control-Allow-Origin

## 哪些操作会造成内存泄漏？

内存泄漏是指任何对象在您不再拥有或者需要它之后仍然存在。

垃圾回收期定期扫描对象，并计算每个对象被其他对象引用的数量。如果一个对象的被引用数量为 0，或者对该对象的唯一引用是循环的，那么该对象的内存即可回收。

1. setTimout 的第一个参数使用字符串而非函数的话，会引发内存泄漏
2. 闭包
3. 控制台日志
4. 循环引用

## Javscript 对象的几种创建方式？

* 字面量
* new Object
* Object.create

## 异步加载和延迟加载

异步：

* 动态插入 `script` 标签
* ajax 获取 js 代码，使用 `eval` 执行
* `script` 标签加上 `defer` 属性或者 `async` 属性：`defer` 是推迟执行，`async` 是加载完就执行
* 创建并插入 iframe

延迟加载：

有些代码在初始化页面的时候并不需要，因此可以延迟加载它

## Flash 和 Ajax 各自的优缺点，在使用中如何取舍？

Flash：

* Flash 适合处理多媒体，矢量图像、访问机器
* 对 CSS、处理文本上不足，不利于 SEO

ajax：

* Ajax 对 CSS，文本支持很好，支持搜索
* 多媒体，矢量图形，机器访问不足

共同点：

* 与服务器交互，无刷新传递消息
* 可以检测用户连线和在线状态
* 操作 DOM

## 请解释一下 js 的同源策略？

同源策略是客户端脚本的重要安全度量标准。它最早出自 Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。

这里的同源策略指的是：协议、域名、端口号相同。

同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性，执行同源窗口的代码。

为什么要有同源策略：

同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

## 什么是 'use strict;'？使用它的好处和坏处分别是什么？

ES5 添加了第二种运行模式，严格模式，这种模式使得 Javascript 在更严格的条件下运行。

优点：

* 效率更高
* 语义更明确
* 更稳定、更安全
* 为未来增加更多可能性，提前做好向后兼容

缺点：

* 兼容，IE6/7/8/9 均不支持严格模式
* 严格模式改变了语义，依赖这些改变可能会导致没有实现严格模式的浏览器中出现问题或者错误
* 压缩

### 严格模式中的变化

严格模式同时改变了语法及运行时行为。变化通常分为这几类：

* 将问题直接转化为错误（如语法错误或运行时错误）

  * 严格模式下无法再意外创建全局变量。
  * 严格模式会使引起静默失败\(silently fail,注:不报错也没有任何效果\)的赋值操作抛出异常. 例如, NaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常. 任何在正常模式下引起静默失败的赋值操作 \(给不可写属性赋值, 给只读属性\(getter-only\)赋值, 给不可扩展对象\(non-extensible object\)的新属性赋值\) 都会抛出异常:
  * 在严格模式下, 试图删除不可删除的属性时会抛出异常\(之前这种操作不会产生任何效果\)
  * 在Gecko版本34之前，严格模式要求一个对象内的所有属性名在对象内必须唯一。正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。因为只有最后一个属性起作用，当代码要去改变属性值而不是修改最后一个重名属性的时候，复制这个对象就产生一连串的bug。在严格模式下，重名属性被认为是语法错误。
  * 严格模式要求函数的参数名唯一. 在正常模式下, 最后一个重名参数名会掩盖之前的重名参数. 之前的参数仍然可以通过 arguments\[i\] 来访问, 还不是完全无法访问. 然而, 这种隐藏毫无意义而且可能是意料之外的 \(比如它可能本来是打错了\), 所以在严格模式下重名参数被认为是语法错误。
  * 严格模式禁止八进制数字语法. ECMAScript并不包含八进制语法, 但所有的浏览器都支持这种以零\(0\)开头的八进制语法: 0644 === 420 还有 "\045" === "%".在ECMAScript 6中支持为一个数字加"0o"的前缀来表示八进制数.
  * ECMAScript 6中的严格模式禁止设置primitive值的属性.不采用严格模式,设置属性将会简单忽略\(no-op\),采用严格模式,将抛出TypeError错误

* 简化了如何为给定名称的特定变量计算

  * 严格模式禁用 `with`
  * 严格模式下的 `eval` 不再为上层范围\(surrounding scope,注:包围eval代码块的范围\)引入新变量
  * 严格模式禁止删除声明变量

* 简化了 `eval` 以及 `arguments`

  * 名称 eval 和 arguments 不能通过程序语法被绑定\(be bound\)或赋值. 
  * 严格模式下，参数的值不会随 arguments 对象的值的改变而变化。
  * 不再支持 arguments.callee

* 将写"安全“JavaScript的步骤变得更简单

  * 在严格模式下通过 `this` 传递给一个函数的值不会被强制转换为一个对象
  * 在严格模式中再也不能通过广泛实现的ECMAScript扩展“游走于”JavaScript的栈中
  * 严格模式下的 `arguments` 不会再提供访问与调用这个函数相关的变量的途径。

* 以及改变了预测未来 ECMAScript 行为的方式。

  * 在严格模式中一部分字符变成了保留的关键字。这些字符包括 `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static` 和 `yield`。
  * 严格模式禁止了不在脚本或者函数层面上的函数声明。

## GET 和 POST 的区别，何时使用 POST?

* 语义：GET 用于信息获取，POST 则用于信息的提交。
* 参数传递：GET 使用 URL 传递传输，POST 使用请求体传递参数。这也导致服务器获取参数的方式不同。
* 参数长度：GET 有限制，IE为2083byte，Chrome 为 8182，服务器对此也都有各自限制；POST 没有限制。
* 安全性：由于 GET 使用 URL 传输参数，参数更易被获取，因此安全性 GET &lt; POST

上面的差异就决定了 POST 的使用场景：更安全、参数长度、保存或者修改数据

## 哪些地方会出现 CSS 阻塞，哪些地方会出现 js 阻塞？

浏览器有并行下载数量限制

* CSS：生成 render 树的时候
* JS：下载的时候会阻塞其他资源下载、执行都会影响

## eval 是做什么的？

`eval()` 函数会将传入的字符串当做 JavaScript 代码进行执行。

在代码中绝不应该使用该函数，非常不安全，也很耗时，因为要调用 js 解释器

## .call 和 .apply 的作用？

动态改变某个类的某个方法的运行环境

## typeof 和 instanceof 区别？举例说明

## 说说 Object.assign\(\) 和 Object.create\(\)

## Object.prototype.toString.call\(\) 具体做了什么

## javascript 类型哪几种？es6 新增的 symbol 对象，有什么作用？

### 基本类型：

基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：string，number，bigint，boolean，null，undefined，symbol \(ECMAScript 2016新增\)。

所有基本类型的值都是不可改变的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。

### 基本类型包装对象

* String 为字符串基本类型。
* Number 为数值基本类型。
* BigInt 为大整数基本类型。
* Boolean 为布尔基本类型。
* Symbol 为字面量基本类型。

## 怎么检查对象类型？

## javascript为什么是单线程？知道event loop吗？实现一个

## 垃圾回收

JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。

### 什么是垃圾

一般来说没有被引用的对象就是垃圾，就是要被清除，例如有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

### 回收机制

JS 的垃圾回收机制有两种：标记清除、引用计数

* **标记清除：**

  * 标记阶段：从根集合出发，将所有活动对象及其子对象打上标记
  * 清除阶段：遍历堆，将非活动对象（未打上标记）的连接到空闲链表上

  _优点：_

  * 实现简单， 容易和其他算法组合

  _缺点：_

  * 碎片化， 会导致无数小分块散落在堆的各处
  * 分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
  * 与写时复制技术不兼容，因为每次都会在活动对象上打上标记

* **引用计数：**

  引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为 0 则直接回收内存。

  _优点：_

  * 可即刻回收垃圾
  * 最大暂停时间短
  * 没有必要沿指针查找， 不要和标记-清除算法一样沿着根集合开始查找

    _缺点：_

  * 计数器的增减处理繁重

  * 计数器需要占用很多位
  * 实现繁琐复杂， 每个赋值操作都得替换成引用更新操作
  * 循环引用无法回收

> [几种垃圾回收算法](https://www.jianshu.com/p/a8a04fd00c3c)  
> [V8 之旅： 垃圾回收器](http://newhtml.net/v8-garbage-collection/)

## `==`、`===` 和 `Object.is` 之间的区别

| 判断 | == | === | Object.is |
| :--- | :--- | :--- | :--- |
| null 与 undefined |  |  |  |



